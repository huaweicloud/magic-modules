<% if false # the license inside this if block pertains to this file -%>
  # Copyright 2017 Google Inc.
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
<% end -%>
<%   unless property.from_response.nil? -%>
func flatten<%= prefix -%><%= titlelize(property.name) -%>(d interface{}, arrayIndex map[string]int) (interface{}, error) {
<%   f = property.from_response
     set_property_value(property, "from_response", nil)
     prefix = prefix + "Custom"
-%>
    v, err := <%= convert_parameter(property, "d, arrayIndex", prefix, "Read") %>
    if err != nil {
        return nil, err
    }
    <%= lines(f) -%>
}
<%   end -%>
<% nested_properties = nested_properties(property) -%>
<% if property.is_a?(Api::Type::Array) && property.item_type.is_a?(Api::Type::NestedObject) -%>
func flatten<%= prefix -%><%= titlelize(property.name) -%>(d interface{}, arrayIndex map[string]int) (interface{}, error) {
    newArrayIndex := make(map[string]int)
    if arrayIndex != nil {
        for k, v := range arrayIndex {
            newArrayIndex[k] = v
	}
    }

    v, err := navigateValue(d, []string{<%= index2navigate(property.field) %>}, newArrayIndex)
    if err != nil {
    	return nil, err
    }

    n := len(v.([]interface{}))
    resp := make([]interface{}, 0, n)
    for i := 0; i < n; i++ {
        newArrayIndex["<%= property.field %>"] = i
        transformed := make(map[string]interface{})

<%   nested_properties.each_index do |i|
       prop = nested_properties[i]
       v1 = "#{go_variable(prop.name)}Prop"
-%>
    <%= v1 -%>, err := <%= convert_parameter(prop, "d, newArrayIndex", prefix + titlelize(property.name), "Read") %>
    if err != nil {
        return nil, fmt.Errorf("Error reading <%= property.out_name -%>:<%= prop.out_name %>, err: %s", err)
    }
<%     if prop.is_a?(Api::Type::NestedObject) -%>
    transformed["<%= prop.name -%>"] = []interface{}{<%= v1 %>}
<%     else -%>
    transformed["<%= prop.name -%>"] = <%= v1 %>
<%     end -%>

<%   end -%>
    resp = append(resp, transformed)
    }

    return resp, nil
}
<% elsif property.is_a?(Api::Type::NestedObject) -%>
func flatten<%= prefix -%><%= titlelize(property.name) -%>(d interface{}, arrayIndex map[string]int) (interface{}, error) {
    resp := make(map[string]interface{})

<%   nested_properties.each_index do |i|
       prop = nested_properties[i]
       v1 = "#{go_variable(prop.name)}Prop"
-%>
    <%= v1 -%>, err := <%= convert_parameter(prop, "d, arrayIndex", prefix + titlelize(property.name), "Read") %>
    if err != nil {
        return nil, fmt.Errorf("Error reading <%= property.out_name -%>:<%= prop.out_name %>, err: %s", err)
    }
<%     if prop.is_a?(Api::Type::NestedObject) -%>
    resp["<%= prop.name -%>"] = []interface{}{<%= v1 %>}
<%     else -%>
    resp["<%= prop.name -%>"] = <%= v1 %>
<%     end -%>

<%   end -%>
    return resp, nil
}
<% end # if property.is_a?(Api::Type::Array) -%>
<% unless nested_properties.nil? -%>
<%   nested_properties.each do |prop| -%>

<%= lines(build_flatten_method(prefix + titlelize(property.name), prop), 1) -%>
<%   end -%>
<% end -%>
