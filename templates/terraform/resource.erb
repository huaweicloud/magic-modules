<% if false # the license inside this if block pertains to this file -%>
# Copyright 2017 Google Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
<% end -%>
<%= lines(autogen_notice :go) -%>

package <%= package %>

<%= lines(compile(object.custom_code.constants)) if object.custom_code.constants %>

<%
  resource_name = product_ns + object.name
  properties = object.all_user_properties
  settable_properties = properties.reject(&:output)
  api_name_lower = String.new(product_ns)
  api_name_lower[0] = api_name_lower[0].downcase
-%>

func resource<%= resource_name -%>() *schema.Resource {
    return &schema.Resource{
        Create: resource<%= resource_name -%>Create,
        Read: resource<%= resource_name -%>Read,
        <% if updatable?(object) -%>
        Update: resource<%= resource_name -%>Update,
        <% end -%>
        Delete: resource<%= resource_name -%>Delete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },
        <% unless object.async.nil? -%>
        <%   async_c = object.async.fetch("create", nil)
             async_u = object.async.fetch("update", nil)
             async_d = object.async.fetch("delete", nil)
        -%>

        Timeouts: &schema.ResourceTimeout {
            <% unless async_c.nil? -%>
            Create: schema.DefaultTimeout(<%= sprintf('%d',  async_c&.timeout / 60) -%> * time.Minute),
            <% end -%>
            <% unless async_u.nil? -%>
            Update: schema.DefaultTimeout(<%= sprintf('%d',  async_u&.timeout / 60) -%> * time.Minute),
            <% end -%>
            <% unless async_d.nil? -%>
            Delete: schema.DefaultTimeout(<%= sprintf('%d',  async_d&.timeout / 60) -%> * time.Minute),
            <% end -%>
        },
        <% end -%>
<%= lines(compile(object.custom_code.resource_definition)) if object.custom_code.resource_definition -%>

        Schema: map[string]*schema.Schema{
            "region": &schema.Schema{
                    Type:     schema.TypeString,
                    Optional: true,
                    Computed: true,
            },
<% order_properties(properties).each do |prop| -%>

    <%= lines(build_schema_property(prop, object)) -%>
<% end -%>
<%= lines(compile(object.custom_code.extra_schema_entry)) if object.custom_code.extra_schema_entry -%>
        },
    }
}

func resource<%= resource_name -%>Create(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(GetRegion(d, config), "<%= object.service_type %>")
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    opts := make(map[string]interface{})
<% object.create_opts.each_index do |i|
     prop = object.create_opts[i]
     v2 = i == 0 ? ":=" : "="
     k, v, f = request_property(prop, "d.Get(\"#{prop.out_name}\")", resource_name)
     v1 = "#{go_variable(prop)}Prop"
     if f
-%>
    <%= v1 -%>, err := <%= v %>
    if err != nil {
        return err
    }
<%   else -%>
    <%= v1 -%> := <%= v %>
<%   end -%>
<%   unless prop.send_empty_value -%>
    e, err <%= v2 %> isEmptyValue(reflect.ValueOf(<%= v1 -%>))
    if err != nil {
        return err
    }
    if !e {
        opts["<%= k -%>"] = <%= v1 -%>
    }
<%   else -%>
    if _, ok := d.GetOkExists("<%= prop.out_name %>"); ok {
        opts["<%= k -%>"] = <%= v1 -%>
    }
<%   end -%>

<% end -%>
<% if object.custom_code.encoder -%>
  opts, err = resource<%= resource_name -%>Encoder(d, meta, opts)
  if err != nil {
    return err
  }

<% end -%>
    url, err := replaceVars(d, "<%= collection_url(object) -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    log.Printf("[DEBUG] Creating new <%= object.name -%>: %#v", opts)
<%
   if object.create_verb.nil? || object.create_verb == :POST
     create_verb = 'Post'
     create_link = 'collection(session)'
   elsif object.create_verb == :PUT
     create_verb = 'Put'
     create_link = 'self_link(session)'
   else
     raise "Ansible does not support create_verb #{object.create_verb}"
   end
-%>
    r := golangsdk.Result{}
<% unless object.msg_prefix('create') -%>
    _, r.Err = client.<%= create_verb %>(url, &opts, &r.Body, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
    })
<% else -%>
    _, r.Err = client.<%= create_verb %>(
        url,
        &map[string]interface{}{"<%= object.msg_prefix('create') %>": opts},
        &r.Body,
        &golangsdk.RequestOpts{OkCodes: successHTTPCodes,})
<% end -%>
    if r.Err != nil {
        return fmt.Errorf("Error creating <%= object.name -%>: %s", r.Err)
    }

<% unless (object.async && object.async.include?("create"))
     keys = []
     if object.msg_prefix('create')
       keys.push("\"#{object.msg_prefix('create')}\"")
     end # object.msg_prefix
     keys.push("\"#{object.resource_id}\"")
-%>
    id, err := navigateMap(r.Body, []string{<%= keys.compact.join(', ') %>})
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id.(string))
<% else -%>
    <%= lines(build_resource_async_op(object, "Create"), 1) %>
    if err != nil {
        return err
    }
    id, err := navigateMap(obj, []string{<%= path2navigate(object.async.fetch("create").result.path) %>})
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id.(string))
<% end # unless object.async -%>
<%= lines(compile(object.custom_code.post_create)) if object.custom_code.post_create -%>

    return resource<%= resource_name -%>Read(d, meta)
}

func resource<%= resource_name -%>Read(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(GetRegion(d, config), "<%= object.service_type %>")
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    url, err := replaceVars(d, "<%= self_link_url(object) -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    r := golangsdk.Result{}
    _, r.Err = client.Get(
        url, &r.Body,
        &golangsdk.RequestOpts{MoreHeaders: map[string]string{"Content-Type": "application/json"}})
    if r.Err != nil {
        return fmt.Errorf("Error reading %s: %s", fmt.Sprintf("<%= resource_name -%> %q", d.Id()), r.Err)
    }
<% unless object.msg_prefix('read') -%>
    res, ok := r.Body.(map[string]interface{})
    if !ok {
        return fmt.Errorf("Error reading %s: the result is not map", fmt.Sprintf("<%= resource_name -%> %q", d.Id()))
    }
<% else -%>
    v, err := navigateMap(r.Body, []string{"<%= object.msg_prefix('read') %>"})
    if err != nil {
        return fmt.Errorf("Error reading %s: the result does not contain <%= object.msg_prefix('read') %>", fmt.Sprintf("<%= resource_name -%> %q", d.Id()))
    }
    res := v.(map[string]interface{})
<% end -%>
<% if object.custom_code.decoder -%>

  res, err = <%= resource_name -%>Decoder(d, meta, res)
  if err != nil {
    return err
  }
<% end -%>

<% properties_to_show(object).each do |prop|
     k, v, f = response_property(prop, 'v', resource_name)
     v1 = "#{go_variable(prop)}Prop"
-%>
    if v, ok := res["<%= k %>"]; ok {
<%   if f -%>
        <%= v1 %>, err := <%= v %>
        if err != nil {
            return fmt.Errorf("Error reading <%= object.name -%>:<%= prop.out_name %>, err: %s", err)
        }
        if err := d.Set("<%= prop.out_name %>", <%= v1 %>); err != nil {
            return fmt.Errorf("Error reading <%= object.name -%>:<%= prop.out_name %>, err: %s", err)
        }
<%   else -%>
        if err := d.Set("<%= prop.out_name %>", <%= v %>); err != nil {
            return fmt.Errorf("Error reading <%= object.name -%>:<%= prop.out_name %>, err: %s", err)
        }
<%   end -%>
    }

<% end -%>
    return nil
}

<% if updatable?(object) -%>
func resource<%= resource_name -%>Update(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(GetRegion(d, config), "<%= object.service_type %>")
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    <% if object.input -%>
    var obj map[string]interface{}
    var url string
    var res map[string]interface{}
    op := &<%= api_name_lower -%>.Operation{}

    d.Partial(true)

    <% properties_by_custom_update(properties).each do |key, props| -%>
    if <%= props.map { |prop| "d.HasChange(\"#{Google::StringUtils.underscore(prop.name)}\")" }.join ' || ' -%> {
        <% props.each do |prop| -%>
            <% if settable_properties.include? prop -%>
                <%= prop.api_name -%>Prop, err := expand<%= resource_name -%><%= titlelize_property(prop) -%>(d.Get("<%= Google::StringUtils.underscore(prop.name) -%>"), d, config)
            if err != nil {
                return err
            }
            <% else -%>
            <%= prop.api_name -%>Prop := d.Get("<%= Google::StringUtils.underscore(prop.name) -%>")
            <% end -%>
        <% end -%>

        obj = map[string]interface{}{
        <% props.each do |prop| -%>
      <% if prop.update_statement -%>
        <%= prop.api_name -%>": <%= compile_template(prop.update_statement,
                                                     prefix: resource_name,
                                                     property: prop) -%>
      <% else -%>
            "<%= prop.api_name -%>": <%= prop.api_name -%>Prop,
      <% end -%>
        <% end -%>
        }
        url, err = replaceVars(d, "<%= update_url(object, key[:update_url]) -%>", nil)
        if err != nil {
            return err
        }
        res, err = sendRequest(config, "<%= key[:update_verb] -%>", url, obj)
        if err != nil {
            return fmt.Errorf("Error updating <%= object.name -%> %q: %s", d.Id(), err)
        }

        err = Convert(res, op)
        if err != nil {
            return err
        }

        err = <%= api_name_lower -%>OperationWaitTime(
            config.client<%= product_ns -%>, op, project, "Updating <%= object.name -%>",
            int(d.Timeout(schema.TimeoutUpdate).Minutes()))

        if err != nil {
            return err
        }

        <% props.each do |prop|    -%>
        d.SetPartial("<%= Google::StringUtils.underscore(prop.name) -%>")
        <% end -%>
    }
    <% end -%>

    d.Partial(false)
<%   else # if object.input -%>
    opts := make(map[string]interface{})
<%     object.update_opts.each_index do |i|
         prop = object.update_opts[i]
         v2 = i == 0 ? ":=" : "="
         k, v, f = request_property(prop, "d.Get(\"#{prop.out_name}\")", resource_name)
         v1 = "#{go_variable(prop)}Prop"
         if f
-%>
    <%= v1 -%>, err := <%= v %>
    if err != nil {
        return err
    }
<%       else -%>
    <%= v1 -%> := <%= v %>
<%       end -%>
<%       unless prop.send_empty_value -%>
    e, err <%= v2 %> isEmptyValue(reflect.ValueOf(<%= v1 -%>))
    if err != nil {
        return err
    }
    if !e {
        opts["<%= k -%>"] = <%= v1 -%>
    }
<%       else -%>
    if _, ok := d.GetOkExists("<%= prop.out_name %>"); ok {
        opts["<%= k -%>"] = <%= v1 -%>
    }
<%       end -%>

<%     end -%>
<%# We need to decide what encoder to use here - if there's an update encoder, use that! -%>
<%     if object.custom_code.update_encoder -%>
    opts, err = resource<%= resource_name -%>UpdateEncoder(d, meta, opts)

<%     elsif object.custom_code.encoder -%>
    opts, err = resource<%= resource_name -%>Encoder(d, meta, opts)

<%     end -%>
    url, err := replaceVars(d, "<%= update_url(object, nil) -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    log.Printf("[DEBUG] Updating <%= object.name -%> %q: %#v", d.Id(), opts)
<%= lines(compile(object.custom_code.pre_update)) if object.custom_code.pre_update -%>
<%
       if object.update_verb.nil? || object.update_verb == :PUT
         update_verb = 'Put'
       elsif object.update_verb == :POST
         update_verb = 'Post'
       else
         raise "Ansible does not support update_verb #{object.update_verb}"
       end
-%>
    r := golangsdk.Result{}
<% unless object.msg_prefix('update') -%>
    _, r.Err = client.<%= update_verb %>(url, &opts, &r.Body, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
    })
<% else -%>
    _, r.Err = client.<%= update_verb %>(
        url,
        &map[string]interface{}{"<%= object.msg_prefix('update') %>": opts},
        &r.Body,
        &golangsdk.RequestOpts{OkCodes: successHTTPCodes,})
<% end -%>
    if r.Err != nil {
        return fmt.Errorf("Error updating <%= object.name -%> %q: %s", d.Id(), r.Err)
    }

<%     if object.async && object.async.include?("update") -%>
    <%= lines(build_resource_async_op(object, "Update"), 1) %>
    if err != nil {
        return err
    }
<%     end # unless object.async -%>
<%   end -%>

<%= lines(compile(object.custom_code.post_update)) if object.custom_code.post_update -%>
    return resource<%= resource_name -%>Read(d, meta)
}
<% end -%>

func resource<%= resource_name -%>Delete(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(GetRegion(d, config), "<%= object.service_type %>")
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    url, err := replaceVars(d, "<%= delete_url(object) -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

<%= lines(compile(object.custom_code.pre_delete)) if object.custom_code.pre_delete -%>
    log.Printf("[DEBUG] Deleting <%= object.name -%> %q", d.Id())
    r := golangsdk.Result{}
    _, r.Err = client.Delete(url, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
        JSONResponse: &r.Body,
	MoreHeaders:  map[string]string{"Content-Type": "application/json"},
    })
    if r.Err != nil {
        return fmt.Errorf("Error deleting <%= object.name -%> %q: %s", d.Id(), r.Err)
    }

<% unless object.async && object.async.include?("delete")
-%>
    return nil
<% else -%>
    <%= lines(build_resource_async_op(object, "Delete"), 1) %>
<%   async = object.async.fetch("delete") -%>
<%   unless is_resource_standard_async(object, async) -%>
    _, err = waitToFinish(
        []string{"Done"}, []string{"Pending"},
        d.Timeout(schema.TimeoutDelete),
        <%= sprintf('%d', async.operation.wait_ms / 1000) %> * time.Second,
        func() (interface{}, string, error) {
            resp, err := client.Get(
                url, nil,
                &golangsdk.RequestOpts{MoreHeaders: map[string]string{"Content-Type": "application/json"}})
            if err != nil {
                if _, ok := err.(golangsdk.ErrDefault404); ok{
                    return resp, "Done", nil
                }
                return nil, "", nil
            }
            return resp, "Pending", nil
        },
    )
<%   end # unless is_resource_standard_async -%>
    return err
<% end # unless object.async -%>
}

<% properties_to_show(object).each do |prop| -%>
<%= lines(build_flatten_method(resource_name, prop), 1) -%>
<% end -%>

<% object.all_user_properties.reject(&:output).each do |prop| -%>
<%= lines(build_expand_method(resource_name, prop), 1) -%>
<% end -%>
<% if object.custom_code.encoder -%>

func resource<%= resource_name -%>Encoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
  <%= lines(compile(object.custom_code.encoder)) -%>
}
<% end -%>
<% if object.custom_code.update_encoder-%>

func resource<%= resource_name -%>UpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
  <%= lines(compile(object.custom_code.update_encoder)) -%>
}
<% end -%>
<% if object.custom_code.decoder -%>

func resource<%= resource_name -%>Decoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
  <%= lines(compile(object.custom_code.decoder)) -%>
}
<% end -%>
