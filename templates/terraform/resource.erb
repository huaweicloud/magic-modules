<% if false # the license inside this if block pertains to this file -%>
# Copyright 2017 Google Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
<% end -%>
<%= lines(autogen_notice :go) -%>

package <%= package %>

<%= lines(compile(object.custom_code.constants)) if object.custom_code.constants %>

<%
  resource_name = product_ns + object.name + object.version.upcase
  resource_nestedobj_properties = nestedobject_properties(object)
  ai_name = resource_nestedobj_properties.nil? ? "nil" : "arrayIndex"
-%>

func resource<%= resource_name -%>() *schema.Resource {
    return &schema.Resource{
        Create: resource<%= resource_name -%>Create,
        Read: resource<%= resource_name -%>Read,
        <% if updatable?(object) -%>
        Update: resource<%= resource_name -%>Update,
        <% end -%>
        Delete: resource<%= resource_name -%>Delete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },
	<% at = async_timout(object) %>
        <% unless at.empty? -%>
        Timeouts: &schema.ResourceTimeout {
            <% unless at["create"].nil? -%>
            Create: schema.DefaultTimeout(<%= sprintf('%d',  at["create"] / 60) -%> * time.Minute),
            <% end -%>
            <% unless at["update"].nil? -%>
            Update: schema.DefaultTimeout(<%= sprintf('%d',  at["update"] / 60) -%> * time.Minute),
            <% end -%>
            <% unless at["delete"].nil? -%>
            Delete: schema.DefaultTimeout(<%= sprintf('%d',  at["delete"] / 60) -%> * time.Minute),
            <% end -%>
        },
        <% end -%>
<%= lines(compile(object.custom_code.resource_definition)) if object.custom_code.resource_definition -%>

        Schema: map[string]*schema.Schema{
<% order_properties(object.all_user_properties).each do |prop| -%>
    <%= lines(build_schema_property(prop, object)) -%>

<% end -%>
        },
    }
}

<% create_api = object.apis["create"] -%>
func resource<%= resource_name -%>Create(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(<%= argu_for_sdkclient(create_api) %>)
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    opts := make(map[string]interface{})
<% object.create_opts.each do |prop| -%>
    opts["<%= prop.name %>"] = d.Get("<%= prop.name %>")
<% end -%>
<% unless resource_nestedobj_properties.nil? -%>

    arrayIndex := map[string]int{
<%   resource_nestedobj_properties.each do |i| -%>
	"<%= to_schema_index(i) %>": 0,
<%   end -%>
    }
<% end -%>

    params := make(map[string]interface{})
<%= lines(build_expand_properties(object, create_api.parameters, "create", "opts, " + ai_name, resource_name + titlelize(create_api.name), "params", false), 1) %>

    log.Printf("[DEBUG] Creating new <%= object.name -%>: %#v", params)

    url, err := replaceVars(d, "<%= create_api.path -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    r := golangsdk.Result{}
    _, r.Err = client.<%= create_api.verb.capitalize %>(url, &params, &r.Body, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
    })
    if r.Err != nil {
        return fmt.Errorf("Error creating <%= object.name -%>: %s", r.Err)
    }
<% action = action_after_send_create_request(object) -%>
<% unless action.nil? -%>

    err = action<%= resource_name %><%= titlelize(action.name) %>(d, r.Body, client)
    if err != nil {
        return err
    }
<% end -%>
<% if create_api.async.nil? -%>

    id, err := navigateValue(r.Body, []string{<%= index2navigate(create_api.resource_id_path) %>}, nil)
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id.(string))
<% else -%>

    obj, err := asyncWait<%= resource_name %><%= titlelize(create_api.name) %>(d, config, r.Body, client)
    if err != nil {
        return err
    }
    id, err := navigateValue(obj, []string{<%= index2navigate(create_api.async.result.field) %>}, nil)
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id.(string))
<% end # unless object.async -%>
<% other_api(object, "c").each do | item | -%>

    err = set<%= resource_name %><%= titlelize(item.name) %>(d, opts, <%= ai_name%>, client)
    if err != nil {
        return err
    }
<% end -%>

    return resource<%= resource_name -%>Read(d, meta)
}

<%- read_api = object.apis["read"] %>
func resource<%= resource_name -%>Read(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(<%= argu_for_sdkclient(read_api) %>)
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    url, err := replaceVars(d, "<%= self_link_url(object) -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    r := golangsdk.Result{}
    _, r.Err = client.Get(
        url, &r.Body,
        &golangsdk.RequestOpts{MoreHeaders: map[string]string{"Content-Type": "application/json"}})
    if r.Err != nil {
        return fmt.Errorf("Error reading %s: %s", fmt.Sprintf("<%= resource_name -%> %q", d.Id()), r.Err)
    }
    res, ok := r.Body.(map[string]interface{})
    if !ok {
        return fmt.Errorf("Error reading %s: the result is not map", fmt.Sprintf("<%= resource_name -%> %q", d.Id()))
    }
<% other_api(object, "r").each do | item | -%>

    err = read<%= resource_name %><%= titlelize(item.name) %>(d, client, &res)
    if err != nil {
        return err
    }
<% end -%>

<% properties_to_show(object).each do |prop|
     v1 = "#{go_variable(prop.name)}Prop"
-%>
    <%= v1 %>, err := <%= convert_parameter(prop, 'res, nil', resource_name, "Read") %>
    if err != nil {
        return fmt.Errorf("Error reading <%= object.name -%>:<%= prop.out_name %>, err: %s", err)
    }
<%   if prop.is_a?(Api::Type::NestedObject) -%>
    if err := d.Set("<%= prop.out_name %>", []interface{}{<%= v1 %>}); err != nil {
<%   else -%>
    if err := d.Set("<%= prop.out_name %>", <%= v1 %>); err != nil {
<%   end -%>
        return fmt.Errorf("Error setting <%= object.name -%>:<%= prop.out_name %>, err: %s", err)
    }

<% end -%>
    return nil
}
<% if updatable?(object) -%>

<%   update_api = object.apis.fetch("update", nil) -%>
func resource<%= resource_name -%>Update(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(<%= argu_for_sdkclient(update_api) %>)
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }
<%   unless update_api.nil? -%>

    opts := make(map[string]interface{})
<%     object.update_opts.each do |prop| -%>
    opts["<%= prop.name %>"] = d.Get("<%= prop.name %>")
<%     end -%>
<% unless resource_nestedobj_properties.nil? -%>

    arrayIndex := map[string]int{
<%   resource_nestedobj_properties.each do |i| -%>
	"<%= to_schema_index(i) %>": 0,
<%   end -%>
    }
<% end -%>

    params := make(map[string]interface{})
<%= lines(build_expand_properties(object, update_api.parameters, "update", "opts, " + ai_name, resource_name + titlelize(update_api.name), "params", false), 1) %>

    log.Printf("[DEBUG] Updating <%= object.name -%> %q: %#v", d.Id(), params)

    url, err := replaceVars(d, "<%= update_api.path -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    r := golangsdk.Result{}
    _, r.Err = client.<%= update_api.verb.capitalize %>(url, &params, &r.Body, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
    })
    if r.Err != nil {
        return fmt.Errorf("Error updating <%= object.name -%> %q: %s", d.Id(), r.Err)
    }
<%     unless update_api.async.nil? -%>

    _, err = asyncWait<%= resource_name %><%= titlelize(update_api.name) %>(d, config, r.Body, client)
    if err != nil {
        return err
    }
<%     end # unless object.async -%>
<%   end # update_api.nil -%>
<%   other_api(object, "u").each do | item | -%>

    err = <%= item.crud.include?("c") ? "set" : "update" %><%= resource_name %><%= titlelize(item.name) %>(d, opts, <%= ai_name%>, client)
    if err != nil {
        return err
    }
<%   end -%>

    return resource<%= resource_name -%>Read(d, meta)
}
<% end -%>

<% delete_api = object.apis["delete"] -%>
func resource<%= resource_name -%>Delete(d *schema.ResourceData, meta interface{}) error {
    config := meta.(*Config)
    client, err := config.sdkClient(<%= argu_for_sdkclient(delete_api) %>)
    if err != nil {
        return fmt.Errorf("Error creating sdk client, err=%s", err)
    }

    url, err := replaceVars(d, "<%= delete_api.path -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

<%= lines(compile(object.custom_code.pre_delete)) if object.custom_code.pre_delete -%>
    log.Printf("[DEBUG] Deleting <%= object.name -%> %q", d.Id())
    r := golangsdk.Result{}
    _, r.Err = client.Delete(url, &golangsdk.RequestOpts{
        OkCodes: successHTTPCodes,
        JSONResponse: &r.Body,
	MoreHeaders:  map[string]string{"Content-Type": "application/json"},
    })
    if r.Err != nil {
        return fmt.Errorf("Error deleting <%= object.name -%> %q: %s", d.Id(), r.Err)
    }

<% if delete_api.async.nil? -%>
<%   if create_api.async.nil? -%>
    return nil
<%   else # if create api is async, then it is best to make sure the resource is delete successfully -%>
    url, err := replaceVars(d, "<%= read_api.path -%>", nil)
    if err != nil {
        return err
    }
    url = client.ServiceURL(url)

    _, err = waitToFinish(
        []string{"Done"}, []string{"Pending"},
        d.Timeout(schema.TimeoutDelete),
        <%= sprintf('%d', create_api.async.operation.wait_ms / 1000) %> * time.Second,
        func() (interface{}, string, error) {
            resp, err := client.Get(
                url, nil,
                &golangsdk.RequestOpts{MoreHeaders: map[string]string{"Content-Type": "application/json"}})
            if err != nil {
                if _, ok := err.(golangsdk.ErrDefault404); ok{
                    return resp, "Done", nil
                }
                return nil, "", nil
            }
            return resp, "Pending", nil
        },
    )
    return err
<%   end # unless is_resource_standard_async -%>
<% else -%>
    _, err = asyncWait<%= resource_name %><%= titlelize(delete_api.name) %>(d, config, r.Body, client)
    return err
<% end -%>
}
<% unless create_api.async.nil? -%>

    <%= lines(build_resource_async_op(create_api, "d.Timeout(schema.TimeoutCreate)", resource_name), 1) %>
<% end -%>

<% create_api.parameters.each do |prop| -%>
<%= lines(build_expand_method(object, "create", resource_name + titlelize(create_api.name), prop), 1) -%>
<% end -%>
<% unless delete_api.async.nil? -%>

    <%= lines(build_resource_async_op(delete_api, "d.Timeout(schema.TimeoutDelete)", resource_name), 1) %>
<% end -%>
<% if updatable?(object) && update_api -%>
<%   unless update_api.async.nil? -%>

    <%= lines(build_resource_async_op(update_api, "d.Timeout(schema.TimeoutUpdate)", resource_name), 1) %>
<%   end -%>

<%   update_api.parameters.each do |prop| -%>
<%= lines(build_expand_method(object, "update", resource_name + titlelize(update_api.name), prop), 1) -%>
<%   end -%>
<% end -%>

<% properties_to_show(object).each do |prop| -%>
<%= lines(build_flatten_method(resource_name, prop), 1) -%>
<% end -%>
<% action = action_after_send_create_request(object) -%>
<% if action -%>

<%= lines(build_action_method(object, resource_name, action), 1) -%>
<% end -%>
<% object.apis.values.select { |item| item.is_a? Api::ApiOther }.each do |item| -%>

<%   if item.crud.include? "r" -%>
<%= lines(build_other_r_method(resource_name, item), 1) -%>
<%   else -%>
<%= lines(build_other_cu_method(object, item.crud.include?("c") ? "set" : "update", resource_name, item), 1) -%>

<%     item.parameters.each do |prop| -%>
<%= lines(build_expand_method(object, item.crud.include?("c") ? "create" : "update", resource_name + titlelize(item.name), prop), 1) -%>
<%     end -%>
<%   end -%>
<% end -%>
