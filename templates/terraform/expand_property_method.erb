<% if false # the license inside this if block pertains to this file -%>
  # Copyright 2017 Google Inc.
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
<% end -%>
<% if property.custom_expand -%>
<%= lines(compile_template(property.custom_expand,
                           prefix: resource_name,
                           property: property)) -%>
<% else -%>
<%   go_on = property.to_request.nil? || property.to_request.include?('{class}(')
     postfix = property&.to_request&.include?('{class}(') ? "Internal" : ""
-%>
<%   unless property.to_request.nil? -%>
<%     internal = "expand#{prefix}#{titlelize_property(property)}Internal" -%>

func expand<%= prefix -%><%= titlelize_property(property) -%>(v interface{}) (interface{}, error) {
    <%= lines(convert_custom_method(property, property.to_request, internal)) %>
}
<%   end -%>
<%   if go_on && property.is_a?(Api::Type::NameValues) -%>

func expand<%= prefix -%><%= titlelize_property(property) -%><%= postfix -%>(v interface{}) (map[string]string, error) {
    if v == nil {
        return map[string]string{}, nil
    }
    m := make(map[string]string)
    for k, val := range v.(map[string]interface{}) {
        m[k] = val.(string)
    }
    return m, nil
}
<%   elsif go_on && tf_types.include?(property.class)
       nested_properties = nested_properties(property)
-%>
<%     unless nested_properties.nil? -%>

func expand<%= prefix -%><%= titlelize_property(property) -%><%= postfix -%>(v interface{}) (interface{}, error) {
    l := v.([]interface{})
<%       if property.is_a?(Api::Type::Array) -%>
    req := make([]interface{}, 0, len(l))
    for _, raw := range l {
        if raw == nil {
            continue
        }
<%       else -%>
    if len(l) == 0 || l[0] == nil{
        return nil, nil
    }
    raw := l[0]
<%       end -%>
    original := raw.(map[string]interface{})
    transformed := make(map[string]interface{})

<%       nested_properties.each_index do |i|
           prop = nested_properties[i]
           v2 = i == 0 ? ":=" : "="
           k, v, f = request_property(prop, "original[\"#{prop.out_name}\"]", prefix + titlelize_property(property))
	   v1 = "#{go_variable(prop)}Prop"
           if f
-%>
    <%= v1 -%>, err := <%= v %>
    if err != nil {
        return nil, err
    }
<%         else -%>
    <%= v1 -%> := <%= v %>
<%         end -%>
<%         unless prop.send_empty_value -%>
    e, err <%= v2 %> isEmptyValue(reflect.ValueOf(<%= v1 -%>))
    if err != nil {
        return nil, err
    }
    if !e {
        transformed["<%= k -%>"] = <%= v1 -%>
    }
<%         else -%>
        transformed["<%= k -%>"] = <%= v1 -%>
<%         end -%>

<%       end -%>
<%       if property.is_a?(Api::Type::Array) -%>
    req = append(req, transformed)
    }
    return req, nil
<%       else -%>
    return transformed, nil
<%       end -%>
}
<%       nested_properties.each do |prop| -%>
<%=        lines(build_expand_method(prefix + titlelize_property(property), prop), 1) -%>
<%       end -%>
<%     end # nested_properties.nil? -%>
<%   else -%>
    // TODO: Property '<%= property.name -%>' of type <%= property.class -%> is not supported
<%   end # tf_types.include?(property.class) -%>
<% end # custom_code check -%>
