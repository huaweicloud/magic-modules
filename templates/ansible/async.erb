<% if object.async -%>
<%
  stat_path = path2navigate(object.async.status.path)
  res_path = path2navigate(object.async.result.path)
  op_path = path2navigate(object.async.operation.path)
  async_url = async_operation_url(object, object.async.operation.base_url)
  res_url = async_operation_url(object, object.async.result.base_url)
-%>
def resource_get_url(module, wait_done):
    combined = {'op_id': navigate_hash(wait_done, <%= res_path -%>)}
<% if res_url.include? '{project}' -%>
    combined['project'] = get_project_id(module)
<% end-%>
    url = <%=quote_string(res_url)%>.format(**combined)

    endpoint = get_service_endpoint(module, <%=quote_string(object.service_type)%>)
    return endpoint + url


<%=
  lines(emit_link('async_op_url', async_url, object, true, object.async.operation.service_type || object.service_type), 2)
-%>
def wait_for_operation(module, op_type, op_result):
    op_id = navigate_hash(op_result, <%= op_path -%>)
    url = async_op_url(module, {'op_id': op_id})
    timeout = 60 * int(module.params['timeouts'][op_type].rstrip('m'))

<% if object.self_link_query.nil? -%>
    return wait_for_completion(url, timeout, module)
<% else # object.self_link_query.nil? -%>
    wait_for_completion(status, op_result, resource)
<%=
  lines(format(
    [
      [
        "return fetch_wrapped_resource(resource, #{obj_kind}",
        ("'#{object.self_link_query.kind}'," if object.self_link_query.kind?),
        "'#{object.self_link_query.items}')"
      ].join(' '),
      [
        [
         "return fetch_wrapped_resource(resource, #{obj_kind}",
         ("'#{object.self_link_query.kind}'," if object.self_link_query.kind?)
        ].join(' '),
        indent([
          "'#{object.self_link_query.items}')"
        ], 23) # 23 = align with ( previous line
      ],
      [
        "return fetch_wrapped_resource(resource, #{obj_kind}",
        indent([
          "'#{object.self_link_query.kind}',",
          "'#{object.self_link_query.items}')"
        ], 23) # 31 = align with ( previous line
      ]
    ], 4
  ))
-%>
<% end # object.self_link_query.nil? -%>


def wait_for_completion(op_uri, timeout, module):
<%
  err_path = path2navigate(object.async.error.path)
  # err_msg = object.async.error.message
  allowed_states = object.async.status.allowed.compact.map { |x| quote_string(x) }
  complete_states = object.async.status.complete.compact.map { |x| quote_string(x) }
  allowed_states = [allowed_states, complete_states].flatten
-%>
    end = time.time() + timeout
    while time.time() <= end:
        try:
<% if object.kind? -%>
            op_result = fetch_resource(module, op_uri, '<%= op_kind -%>')
<% else # object.kind? -%>
            op_result = fetch_resource(module, op_uri)
<% end # object.kind? -%>
        except Exception:
            time.sleep(<%= sprintf('%.1f', object.async.operation.wait_ms / 1000.0) %>)
            continue

        raise_if_errors(op_result, module)

        status = navigate_hash(op_result, <%= stat_path -%>)
        if status not in [<%= allowed_states.join(', ') -%>]:
            module.fail_json(msg="Invalid result %s" % status)
        if status in [<%= complete_states.join(', ') -%>]:
            return op_result

        time.sleep(<%= sprintf('%.1f', object.async.operation.wait_ms / 1000.0) %>)

    module.fail_json(msg="Timeout to wait completion")


def raise_if_errors(response, module):
<%
  err_path = path2navigate(object.async.error.path)
  err_msg = path2navigate(object.async.error.message)
-%>
    errors = navigate_hash(response, <%= err_path -%>)
    if errors:
        module.fail_json(msg=navigate_hash(response, <%= err_msg -%>))
<%   if (not async_op_st || async_op_st == object.service_type) && async_op_url == object_self_link -%>


def wait_for_delete(module, link):
    auth = HwcSession(module, <%= quote_string(prod_name) -%>)
    end = time.time() + 60 * int(
        module.params['timeouts']['delete'].rstrip('m'))
    while time.time() <= end:
        try:
            resp = auth.get(link)
            if resp.status_code == 404:
                return
        except Exception:
            pass

        time.sleep(<%= sprintf('%.1f', object.async.operation.wait_ms / 1000.0) %>)

    module.fail_json(msg="Timeout to wait for deletion to be complete")
<%   end -%>
<% end #if object.async -%>
