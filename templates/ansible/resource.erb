#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2019 Huawei
# GNU General Public License v3.0+ (see COPYING or
# https://www.gnu.org/licenses/gpl-3.0.txt)
<%# lines(autogen_notice :python) -%>

from __future__ import absolute_import, division, print_function
__metaclass__ = type

###############################################################################
# Documentation
###############################################################################

<%
  metadata_version = quote_string(@config.manifest.get('metadata_version',
                                                       config))
  supported_by = quote_string(@config.manifest.get('supported_by', config))
-%>
ANSIBLE_METADATA = {'metadata_version': <%= metadata_version -%>,
                    'status': <%= @config.manifest.get('status', config) -%>,
                    'supported_by': <%= supported_by -%>}

DOCUMENTATION = '''
---
module: <%= module_name(object) %>
description:
<%= lines(indent(bullet_lines(object.description, 4), 4)) -%>
short_description: Creates a resource of <%= product_name.capitalize %>/<%= object.name %> in <%= cloud_name %>
version_added: <%= lines(@config.manifest.get('version_added', config)) -%>
author: <%= lines(@config.manifest.get('author', config)) -%>
requirements:
<% @config.manifest.get('requirements', config).each do |line| -%>
<%= lines(indent(bullet_line(line, 4, false, false), 4)) -%>
<% end -%>
options:
    state:
        description:
            - Whether the given object should exist in <%= cloud_name %>.
        choices: ['present', 'absent']
        default: 'present'
    filters:
        description:
            - A list of filters to apply when deciding whether existing
              resources match and should be altered. The item of filters
              is the name of input options.
        required: true
<% at = async_timout(object) -%>
<% unless at.empty? -%>
    timeouts:
        description:
            - The timeouts for each operations.
        type: dict
        suboptions:
<%   unless at["create"].nil? -%>
            create:
                description:
                    - The timeouts for create operation.
                type: str
                default: <%= sprintf('\'%dm\'', at["create"] / 60) %>
<%   end -%>
<%   unless at["update"].nil? -%>
            update:
                description:
                    - The timeouts for update operation.
                type: str
                default: <%= sprintf('\'%dm\'', at["update"] / 60) %>
<%   end -%>
<%   unless at["delete"].nil? -%>
            delete:
                description:
                    - The timeouts for delete operation.
                type: str
                default: <%= sprintf('\'%dm\'', at["delete"] / 60) %>
<%   end -%>
<% end -%>
<% object.not_output_properties.each do |prop| -%>
<%= lines(indent(doc_property_yaml(prop, object, 4), 4)) -%>
<% end -%>
extends_documentation_fragment: hwc
'''

<%if example -%>
EXAMPLES = '''
<% unless example.description.nil? -%>
# <%= example.description %>
<% end -%>
<% if example.dependencies -%>
<%   example.dependencies.each do |depend| -%>
<%= lines(depend.build_example('present', object)) -%>
<%   end # example.dependencies.each -%>
<% end # if example.dependencies -%>
<%= lines(example.task.build_example('present', object)) -%>
'''

<% end -%>
RETURN = '''
<% object.all_user_properties.each do |prop| -%>
<%= lines(indent(return_property_yaml(prop, 4), 4)) -%>
<% end -%>
'''

###############################################################################
# Imports
###############################################################################

<% cfs = custom_override_methods(object) -%>
<% unless cfs.empty? -%>
from ansible.modules.cloud.<%= module_dir %>.custom_functions import (
<%   last_item = cfs.pop -%>
<%   cfs.each do |i| -%>
    <%= i %>,
<%   end -%>
    <%= last_item %>)

<% end -%>
from ansible.module_utils.hwc_utils import (
<%= module_import_items(object) %>
<%
  # imports = ['json']
  # imports << 're'
-%>
<%# = lines(imports.sort.uniq.map { |i| "import #{i}" }) -%>

###############################################################################
# Main
###############################################################################


def build_module():
<%
  mod_props = object.not_output_properties.map do |prop|
    python_dict_for_property(prop, object)
  end
-%>
    return HwcModule(
        argument_spec=dict(
            state=dict(default='present', choices=['present', 'absent'],
                       type='str'),
            filters=dict(required=True, type='list', elements='str'),
<% unless at.empty? -%>
            timeouts=dict(type='dict', options=dict(
<%   unless at["create"].nil? -%>
                create=dict(default=<%= sprintf('\'%dm\'', at["create"] / 60) -%>, type='str'),
<%   end -%>
<%   unless at["update"].nil? -%>
                update=dict(default=<%= sprintf('\'%dm\'', at["update"] / 60) -%>, type='str'),
<%   end -%>
<%   unless at["delete"].nil? -%>
                delete=dict(default=<%= sprintf('\'%dm\'', at["delete"] / 60) -%>, type='str'),
<%   end -%>
            ), default=dict()),
<% end -%>
<%= lines(indent_list(mod_props, 12)) -%>
        ),
        supports_check_mode=True,
    )


def main():
    """Main function"""

    module = build_module()
    config = Config(module, "<%= object.__product.prefix[1..-1] %>")

<% list_api = object.apis.fetch("list", nil)
   raise "no list api" if list_api.nil?
-%>
    try:
        resource = None
        if module.params['id']:
            resource = True
        else:
            v = search_resource(config)
            if len(v) > 1:
                raise Exception(
                    "find more than one resources(%s)" % ", ".join([
                            navigate_value(i, [<%= index2navigate(list_api.resource_id_path) %>])
                            for i in v
                        ]))

            if len(v) == 1:
                resource = v[0]
                module.params['id'] = navigate_value(resource, [<%= index2navigate(list_api.resource_id_path) %>])

        result = {}
        changed = False
        if module.params['state'] == 'present':
            if resource is None:
                if not module.check_mode:
                    result = create(config)
                    result['id'] = module.params.get('id')
                changed = True

            else:
<% unless updatable?(object) -%>
                result = read_resource(config)
<% else -%>
                current = read_resource(config, exclude_output=True)
                expect = user_input_parameters(module)
                if are_different_dicts(expect, current):
                    if not module.check_mode:
                        result = update(config)
                    changed = True
                else:
                    result = read_resource(config)
<% end # updateable(object)? -%>
                result['id'] = module.params.get('id')
        else:
            if resource:
                if not module.check_mode:
                    delete(config)
                changed = True

    except Exception as ex:
        module.fail_json(msg=str(ex))

    else:
        result['changed'] = changed
        module.exit_json(**result)


def user_input_parameters(module):
    return {
<% object.not_output_properties.each do |prop| -%>
        "<%= prop.out_name %>": module.params.get("<%= prop.out_name %>"),
<% end -%>
    }


<% create_api = object.apis["create"] -%>
def create(config):
    module = config.module
    client = config.client(<%= argu_for_sdkclient(create_api) %>)
<% unless at["create"].nil? -%>
    timeout = 60 * int(module.params['timeouts']['create'].rstrip('m'))
<% end -%>
    opts = user_input_parameters(module)

    params = build_create_parameters(opts)
    r = send_create_request(module, params, client)
<% if create_api.async.nil? -%>
    module.params['id'] = navigate_value(r, [<%= index2navigate(create_api.resource_id_path ) %>])
<% else -%>
    obj = async_wait_create(config, r, client, timeout)
    module.params['id'] = navigate_value(obj, [<%= index2navigate(create_api.async.result.field) %>])
<% end -%>
<% other_api(object, "c").each do | item | -%>
<%
     r = item.async.nil? ? "" : "r = "
     spaces = item.parameters.nil? ? "" : "    "
-%>

<%   unless item.parameters.nil? -%>
    params = build_<%= item.out_name %>_parameters(opts)
    if params:
<%   end -%>
    <%= spaces %><%= r %>send_<%= item.out_name %>_request(module, <%= item.parameters.nil? ? "None" : "params" %>, client)
<%   unless item.async.nil? -%>
    <%= spaces %>async_wait_<%= item.out_name %>(config, r, client, timeout)
<%   end -%>
<% end -%>

    return read_resource(config)
<% if updatable?(object) -%>


def update(config):
    module = config.module
    client = config.client(<%= argu_for_sdkclient(create_api) %>)
<%   unless at["update"].nil? -%>
    timeout = 60 * int(module.params['timeouts']['update'].rstrip('m'))
<%   end -%>
    opts = user_input_parameters(module)
<%   update_api = object.apis.fetch("update", nil) -%>
<%   unless update_api.nil? -%>
<%     r = update_api.async.nil? ? "" : "r = " -%>

    params = build_update_parameters(opts)
    if params:
        <%= r %>send_update_request(module, params, client)
<%     unless update_api.async.nil? -%>
        async_wait_update(config, r, client, timeout)
<%     end -%>
<%   end # update_api.nil? -%>
<%   other_api(object, "u").each do | item | -%>
<%
       r = item.async.nil? ? "" : "r = "
       spaces = item.parameters.nil? ? "" : "    "
-%>

<%     unless item.parameters.nil? -%>
    params = build_<%= item.out_name %>_parameters(opts)
    if params:
<%     end -%>
    <%= spaces %><%= r %>send_<%= item.out_name %>_request(module, <%= item.parameters.nil? ? "None" : "params" %>, client)
<%     unless item.async.nil? -%>
    <%= spaces %>async_wait_<%= item.out_name %>(config, r, client, timeout)
<%     end -%>
<%   end -%>

    return read_resource(config)
<% end # updatable? -%>


<% read_api = object.apis["read"] -%>
def delete(config):
    module = config.module
    client = config.client(<%= argu_for_sdkclient(create_api) %>)
<% unless at["delete"].nil? -%>
    timeout = 60 * int(module.params['timeouts']['delete'].rstrip('m'))
<% end -%>
<% delete_api = object.apis["delete"] -%>
<%
   r = delete_api.async.nil? ? "" : "r = "
   spaces = delete_api.parameters.nil? ? "" : "    "
-%>

<% unless delete_api.parameters.nil? -%>
    opts = user_input_parameters(module)
    params = build_delete_parameters(opts)
    if params:
<% end -%>
    <%= spaces %><%= r %>send_delete_request(module, <%= delete_api.parameters.nil? ? "None" : "params" %>, client)
<% unless delete_api.async.nil? -%>
    <%= spaces %>async_wait_delete(config, r, client, timeout)
<% else -%>
<%   unless create_api.async.nil? -%>

<%   # if create api is async, then it is best to make sure the resource is delete successfully -%>
<%     if !read_api.nil? -%>
    url = build_path(module, "<%= read_api.path -%>")
<%     end -%>

    def _refresh_status():
        try:
            client.get(url)
        except HwcClientException404:
            return True, "Done"

        except Exception:
            return None, ""

        return True, "Pending"

    timeout = 60 * int(module.params['timeouts']['create'].rstrip('m'))
    try:
        wait_to_finish(["Done"], ["Pending"], _refresh_status, timeout)
    except Exception as ex:
        module.fail_json(msg="module(<%= module_name(object) %>): error "
                             "waiting for api(delete) to "
                             "be done, error= %s" % str(ex))
<%   end -%>
<% end -%>


def read_resource(config, exclude_output=False):
    module = config.module
    client = config.client(<%= argu_for_sdkclient(read_api) %>)

    res = {}
<% read_apis = [read_api, other_api(object, "r")].flatten.compact -%>
<% read_apis.each do | item | -%>
    r = send_<%= item.out_name%>_request(module, client)
    fill_<%= item.out_name%>_resp_body(r)
    res["<%= item.name %>"] = r
<% end -%>

    return update_properties(module, res, exclude_output)
<% ql = build_list_query_params(list_api, 4) -%>
<% unless ql.empty? -%>


def _build_query_link(opts):
<%=  lines(ql) -%>

    return query_link
<% end -%>


def search_resource(config):
    module = config.module
    client = config.client(<%= argu_for_sdkclient(list_api) %>)
    opts = user_input_parameters(module)
    identity_obj = _build_identity_object(module, opts)
<% unless ql.empty? -%>
    query_link = _build_query_link(opts)
<% end -%>
<% if list_api.path.include?("{") -%>
    link = build_path(module, "<%= list_api.path %>")<%= ql.empty? ? "" : " + query_link" %>
<% else -%>
    link = <%= sprintf("\"%s\"", list_api.path) %><%= ql.empty? ? "" : " + query_link" %>
<% end -%>

<% if list_api.query_params.include?('marker') -%>
    result = []
    p = {'marker': ''}
    while True:
        url = link.format(**p)
        r = send_<%= list_api.out_name %>_request(module, client, url)
        if not r:
            break

        for item in r:
            if not are_different_dicts(identity_obj, item):
                result.append(item)

        if len(result) > 1:
            break

        p['marker'] = r[-1].get(<%= quote_string(list_api.resource_id_path) -%>)

    return result
<% elsif list_api.query_params.include?('offset') -%>
    result = []
    p = {'offset': 0}
    while True:
        url = link.format(**p)
        r = send_<%= list_api.out_name %>_request(module, client, url)
        if not r:
            break

        for item in r:
            if not are_different_dicts(identity_obj, item):
                result.append(item)

        if len(result) > 1:
            break

        p['offset'] += 1

    return result
<% elsif list_api.query_params.include?('start') -%>
    result = []
    p = {'start': 1}
    while True:
        url = link.format(**p)
        r = send_<%= list_api.out_name %>_request(module, client, url)
        if not r:
            break

        for item in r:
            if not are_different_dicts(identity_obj, item):
                result.append(item)

        if len(result) > 1:
            break

        p['start'] += len(r)

    return result
<% else -%>
    r = send_<%= list_api.out_name %>_request(module, client, link)
    if not r:
        return []

    return [item for item in r if not are_different_dicts(identity_obj, item)]
<% end -%>
<% create_apis = [create_api, other_api(object, "c")].flatten.compact -%>
<% create_apis.each do | item | -%>
<%   unless item.parameters.nil? -%>


<%= lines(build_request_body_method(object, item)) -%>
<%   end -%>


<%= lines(build_send_request_method(item, module_name(object))) -%>
<%   unless item.async.nil? -%>


<%= lines(build_resource_async_op(item, module_name(object))) -%>
<%   end -%>
<% end -%>
<% if updatable?(object) -%>
<%   update_apis = [update_api, other_api(object, "u")].flatten.compact -%>
<%   update_apis.each do | item | -%>
<%     next if item.is_a?(Api::ApiOther) && item.crud.include?("c") -%>
<%     unless item.parameters.nil? -%>


<%= lines(build_request_body_method(object, item)) -%>
<%     end -%>


<%= lines(build_send_request_method(item, module_name(object))) -%>
<%     unless item.async.nil? -%>


<%= lines(build_resource_async_op(item, module_name(object))) -%>
<%     end -%>
<%   end -%>
<% end -%>
<% unless delete_api.parameters.nil? -%>


<%= lines(build_request_body_method(object, delete_api)) -%>
<% end -%>


<%= lines(build_send_request_method(delete_api, module_name(object))) -%>
<% unless delete_api.async.nil? -%>


<%= lines(build_resource_async_op(delete_api, module_name(object))) -%>
<% end -%>
<% read_apis.each do | item | -%>


<%= lines(build_read_method(item, module_name(object), false)) -%>


<%= lines(build_fill_resp_body_method(item)) -%>
<% end -%>


<%= lines(build_update_properties_method(object)) -%>


<%= lines(build_read_method(list_api, module_name(object), true)) -%>


<%= lines(build_identity_object_method(object, list_api)) -%>


if __name__ == '__main__':
    main()
